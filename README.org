#+title:  Dani's GNU Emacs config file
#+author: danirod

* Introduction

This is the configuration files for my GNU Emacs distribution. Apparently, you
can use org-mode to do literate programming, so I'm using org-mode to write my
init.el! ðŸ˜Š

This will allow me to document my learnings and discoveries about GNU Emacs as
a long term Vim user. Nothing wrong with Vim, but I wanted to see what is in
the other side of the wall!

* The basics: some notes about surviving Emacs

One of the reasons I delayed trying Emacs seriously is that I'm afraid about
how hard it would be to pick the new shortcut bindings, after getting used to
Vim for so many years. It turns out, it is not that difficult.

The most important thing is knowing about CONTROL and about META. CONTROL is
the CTRL key in the keyboard. META is usually the ALT key in the keyboard (on
Mac keyboards, ALT is usually known as OPTION). Many terminals allow forwarding
the META key to the application. Those that don't, it is possible to emulate
META by pressing ESC.

In Emacs keys are pressed in chords. Unlike Vim, there is no INSERT mode. If
you press A in Emacs, you'll type "a" in your file. You have to use CONTROL and
META chords to do actions. For instance, C-n means CONTROL+n, C-N means
CONTROL+MAYUS+n. M-n means ALT+n, or "ESC n". Sometimes multiple keys have to
be pressed in different combinations. For instance, "C-x C-s" means hold
Control, press "x", keep Control pressed, now press "s".

Important motions to remember:

- C-x f: set fill width (characters per line).
- M-q: format paragraph (causes to be reindented according to the fill width).

Sometimes there is an universal argument:

- It can be used to repeat the number of times to apply an operation.
  For instance, =C-u 4 C-n= moves the cursor 4 lines below.
- It can be used to provide parameters numerically, instead of using it
  interactive, for instance, =C-u 72 C-x f= would automatically set the
  fill width to 72 without asking for it.

** TODO Describe motions

* Package managers

There are a lot of packages in ELPA (Emacs Lisp Package Manager):
<https://elpa.gnu.org>. There are additional packages in MELPA, another
package repository: <https://melpa.org>. Many new features can be added to
GNU Emacs using a package manager, such as support for state of the art
technologies like prettier or eslint, project managers, RSS readers and more.

Here is where I add MELPA to the list of package repositories and initialise
the package system.

#+BEGIN_SRC emacs-lisp
  (require 'package)

  (setq package-archives
        '(("GNU ELPA" . "https://elpa.gnu.org/packages/")
          ("MELPA Stable" . "https://stable.melpa.org/packages/")
          ("MELPA" . "https://melpa.org/packages/"))

        package-archive-priorities '(("MELPA Stable" . 30)
                                     ("MELPA" . 20)
                                     ("GNU ELPA" . 10))

        package-enable-at-startup nil)

  (package-initialize)
#+END_SRC

The following piece of code will make sure that use-package is present. The
cool thing about use-package is that it automatically installs packages if
they were not installed, which is good if I want to install this
configuration file in a new (or an old) computer.

#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (setq use-package-always-ensure t)
#+END_SRC

Combined with the =package-enable-at-startup= option set to nil previously,
this will allow me to manually startup packages using =use-package=. The cool
part about =use-package= is that when you call the primitive, you can also
pass configurations, binds, commands... so everything will stay together.

* Basic configuration

** Appearance and aesthetics

One of the first things to do is to disable the welcome screen. I still feel
welcomed anyway. Thanks a lot! If running =emacs= without an initial file
(i.e. not =emacs whatever.rb=, this will start with a =*scratch*= buffer).

#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-screen t)
#+END_SRC

It is important for me to differentiate between running GNU Emacs in a command
line and GNU Emacs as a standalone graphical application in my window manager,
given that sometimes I'm too lazy to even run =startx= in FreeBSD...

The following piece of code will set some frame parameters only if the
system is graphical. Note that I also make some design choices depending
on whether I'm using a Mac or not.

#+BEGIN_SRC emacs-lisp
  (when window-system
    (let* ((is-mac (eq system-type 'darwin))
           (frame-font (if is-mac "Menlo 12" "Dejau Sans Mono 10"))
           (frame-params (list '(width . 150) '(height . 40)
                               (cons 'font frame-font)
                               '(fullscreen . maximized))))
      (append frame-params initial-frame-alist)
      (append frame-params default-frame-alist)
      (tool-bar-mode -1)
      (scroll-bar-mode -1)
      (when is-mac
        (setq
         mac-command-modifier 'meta
         mac-option-modifier 'none))))
#+END_SRC

Also it is a good time to setup the theme, which is only enable when using
a GUI, because it requires a lot of colors and I don't usually have a lot of
colors in my terminal.

#+BEGIN_SRC emacs-lisp
  (use-package vs-light-theme
    :when window-system
    :init
    (load-theme 'vs-light t))
#+END_SRC

I don't know if this is the proper place to do this, but this is a
purely cosmetic thing. The following modes will display the clock and
time in the system.

#+BEGIN_SRC emacs-lisp
  (display-time-mode)
  (display-battery-mode)
#+END_SRC

** Core settings

Disable globally backup files. I will usually rely on a version control
system to store previous versions of files, so these backup files are
very annoying.

As a side effect, I'm considering setting a different common directory
to store things like this. I've done this with Vim because it allows me
to store a bigger undolist, but I don't know yet if Emacs has this
niceties.

#+BEGIN_SRC emacs-lisp
  (setq make-backup-files nil
        auto-save-default nil)
#+END_SRC

Define a macro to automatically reload the init.el file. This is useful
when I waste minutes trying out things.

#+BEGIN_SRC emacs-lisp
  (defun danirod/reconf-emacs ()
    (interactive)
    (load-file (expand-file-name "init.el" user-emacs-directory)))
#+END_SRC

** Programming

In regards to the main topic: programming. Configure a few things in
prog-mode-hook to make programming nicer:

#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook 'display-line-numbers-mode)
  (add-hook 'prog-mode-hook 'display-fill-column-indicator-mode)

  ;; Relative numbers -- I don't know how to feel about it yet.
  ;; (setq display-line-numbers-type 'relative)
#+END_SRC

Also disable the backup files because I will usually have Git available to do
that.

#+BEGIN_SRC emacs-lisp
  (setq make-backup-files nil
        auto-save-default nil)
#+END_SRC

* Ivy

Ivy and Counsel are packages that provide completions, menus and such.

#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :init
    (ivy-mode t)
    :config
    (setq ivy-use-virtual-buffers t
          ivy-height 20))

  (use-package counsel
    :after ivy
    :bind (("M-x" . counsel-M-x)
           ("C-s" . swiper)
           ("C-x C-f" . counsel-find-file)
           ("C-c C-t" . counsel-git-grep)
           ("C-x C-j" . counsel-file-jump)))
#+END_SRC

* Org-mode

Some interesting facts about Org-mode.

There is an operation in Org mode called =org-edit-special=. You can use
this to extract the snippet of code where the cursor is in, into a
separate buffer, that you can use to edit separately: =C-c '=.

Then you can save your thing with =C-c '= again, and it will be updated
in the original buffer. I'm using this in this very own file to modify
and update each snippet separately without surrounding text nearby.

The following settings are changed by the following block:

- Enables =org-indent-mode= and =auto-fill-mode=. A nice addition,
  because I want my text to look pretty. There are barbarians that do
  not line break their after 72 characters, can you believe?
- For the same purpose, I add a ruler.
- Additionally, make the tabulator work properly.

#+BEGIN_SRC emacs-lisp
  (use-package org
    :init
    (setq org-src-tab-acts-natively t)
    :hook ((org-mode . auto-fill-mode)
           (org-mode . org-indent-mode)
           (org-mode . ruler-mode)))
#+END_SRC

* Language support

Some programming languages are still not supported out of the box.

** TypeScript

#+BEGIN_SRC emacs-lisp
  (use-package typescript-mode)
#+END_SRC

** YAML

#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :mode ("\\.yml$" . yaml-mode))
#+END_SRC

** Ruby

Ruby is supported out of the box, but here are a few fancy things.

First, support for rbenv is provided via the rbenv package, which allows
me to locally bind to a specific Ruby version depending on the project I
am working on. (As an aside, this is the only way to fix the weird PATH
shenanigans in MacOS...).

#+BEGIN_SRC emacs-lisp
  (use-package rbenv
    :init
    (setq rbenv-modeline-function 'rbenv--modeline-plain)
    :hook ((ruby-mode . global-rbenv-mode)
           (ruby-mode . rbenv-use-corresponding)))
#+END_SRC

Most of the time there is Ruby, there is also Rails and RSpec. The
following thing will install rspec-mode. There are a few cool keys to
use with rspec-mode:

- =C-c , v=: will test this file.
- =C-c , s=: will run a single test.

* Language servers

Let's go to the beefy thing here. LSP. A must. I am going to use lsp-mode.

#+BEGIN_SRC emacs-lisp
  (use-package lsp-mode
    :ensure t
    :init (setq lsp-keymap-prefix "C-c l")
    :hook ((c-mode web-mode javascript-mode typescript-mode ruby-mode go-mode) . lsp)
    :commands lsp)
#+END_SRC

I used to be a polyglot programmer, but I grew up. Now I am interested in way
less programming languages, thus the amount of language servers I'll use is
probably not too large. These are the language servers that I want:

- For C/C++, =clangd=.
- For Ruby, =solargraph=.
- For Go, they seem to prefer =gopls= for now.
- For TypeScript and JavaScript, =typescript-language-server= (formely known
  as =theia-ide=, it will wrap Microsoft's =tsserver=).

Also, enable lsp-ui so that I can autocomplete using company.

#+BEGIN_SRC emacs-lisp
  (use-package lsp-ui
    :ensure t
    :after lsp-mode
    :commands lsp-ui-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :init (global-company-mode))
#+END_SRC

* Extra packages

** Editorconfig

Used for consistency between projects.

#+BEGIN_SRC emacs-lisp
  (use-package editorconfig
    :ensure t
    :init (editorconfig-mode 1))
#+END_SRC

** Projectile

Projectile is a tool for interacting with projects. I use it to manage the
different stuff I work with. I should note in this file the commands to
add a new project, because once I add all my projects, I don't usually touch
the project list very often.

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :init (projectile-global-mode)
    :bind (:map projectile-mode-map
                ("C-c p" . projectile-command-map)))
#+END_SRC

I spend so many time in Ruby on Rails that this is worth. It adds additional
projectile actions such as spawning Rails servers, Rails consoles, Rails
dbconsoles and so.

#+BEGIN_SRC emacs-lisp
  (use-package projectile-rails
    :ensure t
    :after projectile
    :init (projectile-rails-global-mode)
    :bind (:map projectile-rails-mode-map
                ("C-c r" . projectile-rails-command-map)))
#+END_SRC

Also connect Projectile with Counsel:

#+BEGIN_SRC emacs-lisp
#+END_SRC

** Magit

Magit is a tool for interacting with Git that leverages the integrated VCS
functionality present in GNU Emacs.  Here is the manual:
<https://magit.vc/manual/magit/>. Now I just have to... read it.

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :commands magit-status
    :bind (("C-c g" . magit-status)
           ("C-c M-g" . magit-dispatch-popup)))
#+END_SRC

TODO: Evaluate whether I want a git gutter similar to Vim.

** Neotree

I initially tried to use Treemacs, but there are some glitches that disturb
me (such as having a scratch window open if I want to autostart Treemacs).
Therefore, I'm switching to Neotree instead. I don't think there is much
different aside of the bugs...

#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons)

  (use-package neotree
    :after all-the-icons
    :bind ("C-c t" . neotree-toggle)
    :config
    (setq neo-theme (if window-system 'icons 'arrows)))
#+END_SRC

** Elcord

This is a funny one: Elcord integrates with the Discord Rich Presence system to
present the file I am editing if I am connected to Discord. Not useful at work
(I don't have Discord installed in my work computer and it would be probably
not a good idea to reveal the file names I work with), but a nice addition at
home while working on side projects.

#+BEGIN_SRC emacs-lisp
  (use-package elcord
    :init
    (elcord-mode))
#+END_SRC
