#+title:  Dani's init.org
#+author: danirod
#+date:   2021-10-13

* Introduction

This is the configuration files for my GNU Emacs distribution. Apparently,
you can use org-mode to do literate programming, so I'm using org-mode to
write my init.el! ðŸ˜Š

This will allow me to document my learnings and discoveries about GNU Emacs
as a long term Vim user. Nothing wrong with Vim, but I wanted to see what is
in the other side of the wall!

* Package managers

There are a lot of packages in ELPA (Emacs Lisp Package Manager):
<https://elpa.gnu.org>. There are additional packages in MELPA, another
package repository: <https://melpa.org>. Many new features can be added to
GNU Emacs using a package manager, such as support for state of the art
technologies like prettier or eslint, project managers, RSS readers and more.

Here is where I add MELPA to the list of package repositories and initialise
the package system.

#+BEGIN_SRC emacs-lisp
  (require 'package)

  (setq package-archives
        '(("GNU ELPA" . "https://elpa.gnu.org/packages/")
          ("MELPA Stable" . "https://stable.melpa.org/packages/")
          ("MELPA" . "https://melpa.org/packages/"))

        package-archive-priorities
        '(("MELPA Stable" . 30)
          ("MELPA" . 20)
          ("GNU ELPA" . 10))

        package-enable-at-startup nil)

  (package-initialize)
#+END_SRC

The following piece of code will make sure that use-package is present. The
cool thing about use-package is that it automatically installs packages if
they were not installed, which is good if I want to install this
configuration file in a new (or an old) computer.

#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
#+END_SRC

Combined with the =package-enable-at-startup= option set to nil previously,
this will allow me to manually startup packages using =use-package=. The cool
part about =use-package= is that when you call the primitive, you can also
pass configurations, binds, commands... so everything will stay together.

* Basic configuration

One of the first things to do is to disable the welcome screen. I still feel
welcomed anyway. Thanks a lot! If running =emacs= without an initial file
(i.e. not =emacs whatever.rb=, this will start with a =*scratch*= buffer).

#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-screen t)
#+END_SRC

It is important for me to differentiate between running GNU Emacs in a command
line and GNU Emacs as a standalone graphical application in my window manager,
given that sometimes I'm too lazy to even run =startx= in FreeBSD...

#+BEGIN_SRC emacs-lisp
  (defvar danirod/font-family)
  (defvar danirod/font-family-large)

  ;; Set the font to be used in graphical environments.
  (if (eq system-type 'darwin)
      (setq danirod/font-family "Menlo 14"
            danirod/font-family-large "Menlo 20")
    (setq danirod/font-family "DejaVu Sans Mono 11"
          danirod/font-family-large "DejaVu Sans Mono 20"))

  (when window-system
    (set-frame-font danirod/font-family)
    (tool-bar-mode -1)
    (scroll-bar-mode -1)
    ;; On a Mac, treat command as option to make it easier.
    ;; (when (eq system-type 'darwin)
    ;;  (setq mac-command-modifier 'meta
    ;;        mac-option-modifier 'none))
    ;; On macOS the menu bar does not bother me, but on other
    ;; platforms, remove the menubar to save precious space,
    ;; and also to force me to learn to use the bindings or M-x.
    (when (not (eq system-type 'darwin))
      (menu-bar-mode -1))

    (defun danirod/start-stream-mode ()
      "When livestreaming or sharing the screen I want the font bigger."
      (interactive)
      (set-frame-font danirod/font-family-large nil nil))
    (defun danirod/stop-stream-mode ()
      "When I stop streaming, I want my fonts to be normal again."
      (interactive)
      (set-frame-font danirod/font-family nil t)))
#+END_SRC

When opening Emacs through a window system, it is important to ensure
that the path is properly set, because otherwise some things that only
are added to the system path when the bashrc is read will be skipped.

#+begin_src emacs-lisp
  (when (memq window-system '(mac ns x))
    (use-package exec-path-from-shell
      :ensure t
      :init (exec-path-from-shell-initialize)))
#+end_src

Also it is a good time to setup the theme, which is only enable when using
a GUI, because it requires a lot of colors and I don't usually have a lot of
colors in my terminal.

#+BEGIN_SRC emacs-lisp
  (when window-system
    (use-package darktooth-theme
      :ensure t
      :init (load-theme 'darktooth t)))

  (global-hl-line-mode 1)
#+END_SRC

In regards to the coding experience, it is mandatory to have relative line
numbers. Same story as Vim motions: how am I supposed to get the distance
between two lines by just looking at the screen, I am not a supercomputer!

#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook 'display-line-numbers-mode)
  (setq display-line-numbers-type 'relative)
#+END_SRC

One of the disadvantages of Emacs is that, because it is not a modal
editor, there is no fast way to just "insert a new line above the
current line" or "insert a new line below the current line".  While
Doom Emacs can solve these things, I'd rather not install full Doom
here, so I'll only sparkle some things that I miss from Vim: motions
for inserting lines on top or below.

For the full list of motions that can be used to create or delete
lines it is useful to know the following motions:

| Motion        | Standard | Action                                           |
|---------------+----------+--------------------------------------------------|
| C-o           | Yes      | Insert a line below this one; cursor stays.      |
| C-k           | Yes      | Delete everything until the end of the line.     |
| C-S-BACKSPACE | Yes      | Delete the entire line.                          |
| C-RET         | No       | Insert a line below this one; move cursor there. |
| C-S-RET       | No       | Insert a line above this one; move cursor there. |

Here are the definitions for these custom motions:

#+begin_src emacs-lisp
  (defun new-line-below ()
    "Insert a new line below this one and jump there"
    (interactive)
    (end-of-line)
    (newline-and-indent))
  (defun new-line-above ()
    "Insert a new line on top of this one and jump there"
    (interactive)
    (beginning-of-line)
    (newline-and-indent)
    (previous-line))

  (global-set-key (kbd "<C-return>") 'new-line-below)
  (global-set-key (kbd "<C-S-return>") 'new-line-above)
#+end_src

Some motions for buffer navigation:

| Motion  | Standard | Action                                                  |
|---------+----------+---------------------------------------------------------|
| C-x o   | Yes      | Move to the next buffer (uses the other-window command) |
| C-x C-o | No       | Move to the next buffer in opposite direction.          |

#+begin_src emacs-lisp
  (defun other-window-backwards ()
    (interactive)
    (other-window -1))

  (global-set-key (kbd "C-x C-o") 'other-window-backwards)
#+end_src

Also, rulers.

#+BEGIN_SRC emacs-lisp
  ;; (add-hook 'prog-mode-hook 'display-fill-column-indicator-mode)
#+END_SRC

Electric indentation.

#+BEGIN_SRC emacs-lisp
  (electric-indent-mode 1)
#+END_SRC

Also disable the backup files because I will usually have Git
available to do that.

#+BEGIN_SRC emacs-lisp
    (setq make-backup-files nil
          auto-save-default nil)
#+END_SRC

* Session management

One of the things that I'd like to improve upon is to avoid restarting
Emacs.  In other words, I should not need to exit Emacs and open it
again when doing things like switching context or tweaking this file.
The following changes will try to make more appealing to just continue
working instead of restart Emacs.

First, talk about closing all the buffers, which is something that
sometimes I'd like to do when switching context to have a clean
workspace before jumping to my next task.  The following custom
function should provide exactly that.

Source: [[https://superuser.com/questions/895920/how-can-i-close-all-buffers-in-emacs][How can I close all buffers in Emacs?]]

#+begin_src emacs-lisp
  (defun close-all-buffers ()
    (interactive)
    (mapc 'kill-buffer (buffer-list)))
#+end_src

And then a quick macro to make reloading the Emacs dotfiles faster:

#+begin_src emacs-lisp
  (defun danirod/reload-config ()
    "Automatically reload the configuration file"
    (interactive)
    (load-file "~/.emacs.d/init.el"))
  (defun danirod/edit-config ()
    "Edit this very file in a different window for faster access"
    (interactive)
    (find-file-other-window "~/.emacs.d/README.org"))
#+end_src

* Org-mode configuration

For some reason some defaults do not usually apply to org-mode...

#+BEGIN_SRC emacs-lisp
  (use-package org
    :hook ((org-mode . auto-fill-mode)
           (org-mode . org-indent-mode)))
#+END_SRC

Now to the real thing. One of the things to configure are fonts.

#+begin_src emacs-lisp
  (add-hook 'org-mode 'variable-pitch-mode)
#+end_src

* Flycheck

#+begin_src emacs-lisp
  (use-package flycheck
    :ensure t
    :config
    (global-flycheck-mode))

  (use-package flycheck-inline
    :ensure t
    :after flycheck
    :config (add-hook 'flycheck-mode-hook 'flycheck-inline-mode))

  (add-hook 'after-init-hook #'global-flycheck-mode)
#+end_src

* Language support

Some programming languages are still not supported out of the box.

** TypeScript

#+BEGIN_SRC emacs-lisp
  (use-package typescript-mode
    :ensure t
    :defer t)
#+END_SRC

** YAML

#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :ensure t
    :defer t)
#+END_SRC

** Ruby

Out of the box, but I'm using rbenv. I do not dislike rvm, but I
prefer rbenv's approach regarding the use of static shims rather than
playing with my PATH.

#+BEGIN_SRC emacs-lisp
  (use-package rbenv
    :ensure t
    :defer t
    :init (global-rbenv-mode)
    :hook ((ruby-mode . rbenv-use-corresponding)))
#+END_SRC

Also some packages useful for Ruby development are sparkled here.

#+begin_src emacs-lisp
  (use-package inf-ruby
    :ensure t
    :hook (ruby-mode . inf-ruby-minor-mode))

  (use-package ruby-refactor
    :ensure t
    :hook (ruby-mode . ruby-refactor-mode-launch))

  (use-package ruby-tools
    :ensure t
    :hook (ruby-mode . ruby-tools-mode))

  (use-package slim-mode :ensure t)

  (use-package rubocop
    :ensure t
    :hook (ruby-mode . rubocop-mode)
    :init (setq rubocop-format-on-save t))
#+end_src

Also add support for RSpec.

#+BEGIN_SRC emacs-lisp
  (use-package rspec-mode
    :ensure t)
#+END_SRC

* Language servers

Let's go to the beefy thing here. LSP. A must. I am going to use lsp-mode.

#+BEGIN_SRC emacs-lisp
  (use-package lsp-mode
    :ensure t
    :init (setq lsp-keymap-prefix "C-c l")
    :hook ((c-mode web-mode javascript-mode typescript-mode ruby-mode go-mode) . lsp)
    :commands lsp)
#+END_SRC

I used to be a polyglot programmer, but I grew up. Now I am interested in way
less programming languages, thus the amount of language servers I'll use is
probably not too large. These are the language servers that I want:

- For C/C++, =clangd=.
- For Ruby, =solargraph=.
- For Go, they seem to prefer =gopls= for now.
- For TypeScript and JavaScript, =typescript-language-server= (formely known
  as =theia-ide=, it will wrap Microsoft's =tsserver=).

Also, enable lsp-ui so that I can autocomplete using company.

#+BEGIN_SRC emacs-lisp
  (use-package lsp-ui
    :ensure t
    :after lsp-mode
    :commands lsp-ui-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :init (global-company-mode))
#+END_SRC

* Helm

Helm is a completion framework for Emacs.

First, let's install it following the docs.

#+begin_src emacs-lisp
  (use-package helm
    :ensure t
    :init (helm-mode t)
    :bind (("M-x" . helm-M-x) ;; override default M-x by helm
           ("C-x C-f" . helm-find-files) ;; override default file find with helm
           ("C-x b" . helm-buffers-list) ;; override default buffers with helm
           ("C-h a" . helm-apropos) ;; override default apropos with helm
           ("M-y" . helm-show-kill-ring) ;; override default killring with helm
           ))
#+end_src

* Extra packages

** Editorconfig

Used for consistency between projects.

#+BEGIN_SRC emacs-lisp
  (use-package editorconfig
    :ensure t
    :init (editorconfig-mode 1))
#+END_SRC

** Projectile

Projectile is a tool for interacting with projects. I use it to manage the
different stuff I work with. I should note in this file the commands to
add a new project, because once I add all my projects, I don't usually touch
the project list very often.

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :init (projectile-global-mode)
    :bind (:map projectile-mode-map
                ("C-c p" . projectile-command-map)))
#+END_SRC

I spend so many time in Ruby on Rails that this is worth. It adds additional
projectile actions such as spawning Rails servers, Rails consoles, Rails
dbconsoles and so.

#+BEGIN_SRC emacs-lisp
  (use-package projectile-rails
    :ensure t
    :after projectile
    :hook ((projectile-mode . projectile-rails-mode))
    :bind (:map projectile-rails-mode-map
                ("C-c r" . projectile-rails-command-map)))
#+END_SRC

** Magit

Magit is a tool for interacting with Git that leverages the integrated VCS
functionality present in GNU Emacs.  Here is the manual:
<https://magit.vc/manual/magit/>. Now I just have to... read it.

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :commands magit-status
    :bind (("C-c g" . magit-status)
           ("C-c M-g" . magit-dispatch-popup)))
#+END_SRC

TODO: Evaluate whether I want a git gutter similar to Vim.

** Neotree

I initially tried to use Treemacs, but there are some glitches that disturb
me (such as having a scratch window open if I want to autostart Treemacs).
Therefore, I'm switching to Neotree instead. I don't think there is much
different aside of the bugs...

#+BEGIN_SRC emacs-lisp
  (use-package neotree
    :ensure t
    :bind (("C-c t" . neotree-toggle))
    :init
    (setq neo-window-position 'right)
    (setq neo-theme 'ascii)
    (setq neo-window-width 30)
    (setq neo-smart-open t))
#+END_SRC

** Elcord

This is a funny one: Elcord integrates with the Discord Rich Presence system to
present the file I am editing if I am connected to Discord. Not useful at work
(I don't have Discord installed in my work computer and it would be probably
not a good idea to reveal the file names I work with), but a nice addition at
home while working on side projects.

#+BEGIN_SRC emacs-lisp
  (use-package elcord
    :ensure t
    :init (elcord-mode))
#+END_SRC

** add-node-modules-path

#+begin_src emacs-lisp
  (use-package add-node-modules-path
    :ensure t
    :hook ((js2-mode . add-node-modules-path)
           (typescript-mode . add-node-modules-path)
           (web-mode . add-node-modules-path)))
#+end_src

** Prettier

Prettier.

#+begin_src emacs-lisp
  (use-package prettier-js
    :ensure t
    :hook ((js2-mode . prettier-js-mode)
           (web-mode . prettier-js-mode)
           (typescript-mode . prettier-js-mode)))
#+end_src

* Footnotes

[fn:1]  It is important to note down that moving the cursor one word
forward actually moves the cursor right after the *current* or next
word.  Therefore, to move the cursor to the beginning of a word, one
M-f less should be pressed.
